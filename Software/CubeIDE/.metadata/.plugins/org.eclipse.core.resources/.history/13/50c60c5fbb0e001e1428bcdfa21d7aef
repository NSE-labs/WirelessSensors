/*
 * SX1262 LoRa transceiver driver
 * Copyright 2023 NSE Labs, LLC
 * Free to use
 */
#include <SX1262.h>
#include "main.h"

SPI_HandleTypeDef *hspi;

/*
 * WaitWhileBusy
 * wait for the busy line on the SX1262 to go low indicating not busy
 * Arguments
 *  timeout in milliseconds (maximum time to wait for line to go low)
 * Return Value
 *  LoRa_OK for success
 *  LoRa_TIMEOUT for timeout
 */
static LoRa_Status WaitWhileBusy(uint16_t timeout)
{
	uint16_t timeoutCounter = 0;

	while(HAL_GPIO_ReadPin(LoRa_BUSY_GPIO_Port, LoRa_BUSY_Pin) == GPIO_PIN_SET)
	{
		timeoutCounter++;
		if(timeoutCounter > timeout)
		{
			return(LoRa_TIMEOUT);
		}
		HAL_Delay (1); /* Delay 1 mS */
	}

	return(LoRa_OK);
}


/*
 * LoRa_Init
 * Initialize the SX1262 chip
 * Arguments
 * 	Pointer to SPI_HandleTypeDef structure for the SPI port used to communicate with the SX1262
 * Return Value
 *  LoRa_OK for success
 *  LoRa_ERROR in case of error
 */
LoRa_Status LoRa_Init(SPI_HandleTypeDef *hspiPtr)
{
	uint8_t xmitBuffer[10];

  /* store the hspi pointer for future use */
  hspi = hspiPtr;

  /* Take SX1262 chip out of reset */
  HAL_GPIO_WritePin(LoRa_NRST_GPIO_Port, LoRa_NRST_Pin, GPIO_PIN_SET);

  /* Wait while the chip finishes its reset sequence */
  if(WaitWhileBusy(10) != LoRa_OK)
  {
	  return(LoRa_ERROR);
  }

  /* Set the chip to Standby mode and using the external oscillator */
  xmitBuffer[0] = LORA_SET_STANDBY_OPCODE;
  xmitBuffer[1] = LORA_STDBY_XOSC;
  if(HAL_SPI_Transmit(hspi, xmitBuffer, 2, 100) != HAL_OK)
  {
	  return LoRa_ERROR;
  }


  return(LoRa_OK);

}

/*
 * LoRaGetStatus
 * Get the current status of the SX1262 chip
 * Arguments
 *  None
 * Return Value
 *  Status byte or 0xFF for error
 *  Status byte defined in SX1262 datasheet
 */
uint8_t LoRaGetStatus(void)
{
	/* Return the status byte from the SX1262 chip */
	uint8_t status = 0;
	uint8_t opcode = LORA_GET_STATUS_OPCODE;

	/* Can use simultaneous TransmitReceive because the SX1262 always sends status while master transmits a command */
	if(HAL_SPI_TransmitReceive(hspi, &opcode, &status, 1, 100) != HAL_OK)
	{
		return 0xFF;
	}

	return status;
}
